<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/png" href="../../logo.png">
    <meta name="theme-color" content="#80deea" />
    <title>Hier - documentation</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css"
      integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/vs2015.min.css"
      integrity="sha512-mtXspRdOWHCYp+f4c7CkWGYPPRAhq9X+xCvJMUBVAb6pqA4U8pxhT3RWT3LP3bKbiolYL2CkL1bSKZZO4eeTew=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <link rel="stylesheet" href="../styles.css" />
  </head>
  <body data-bs-spy="scroll" data-bs-target="#navbar">
    <div class="background home-hero"></div>

    <div class="container-xl">
      <div class="d-flex flex-column flex-md-row shadow">
        <aside class="sidebar glass-bg">
          <nav id="navbar" class="navbar nav-pills navbar-light flex-column align-items-stretch p-3">
            <a class="navbar-brand" href="#">Documentation</a>
            <a class="nav-link" href="#introduction">Introduction</a>
            <a class="nav-link" href="#starter-template">Starter Template</a>
            <a class="nav-link" href="#components">Components</a>
            <nav class="nav nav-pills flex-column">
              <a class="nav-link ms-3 my-1" href="#components-constructor">Constructor</a>
              <a class="nav-link ms-3 my-1" href="#components-lifecycle">Lifecycle</a>
              <a class="nav-link ms-3 my-1" href="#components-props">Properties</a>
              <a class="nav-link ms-3 my-1" href="#components-state">State</a>
            </nav>
            <a class="nav-link" href="#reconcillation">Reconciliation</a>
            <a class="nav-link" href="#parser">Parser</a>
          </nav>
        </aside>

        <main
          class="bg-white documentation-column"
          style="overflow: hidden"
          data-bs-spy="scroll"
          data-bs-target="#navbar"
          data-bs-offset="0"
          tabindex="0"
        >
          <section class="pt-0">
            <h1 id="introduction" class="pt-3">Introduction</h1>
            <div class="lead my-4">
              Hier was invented as an alternative to existing libraries, allowing you to add new functionality to existing
              non-javascript projects without using build systems. The syntax of template literals is very simple and
              already familiar. So why not use all its power, right?
            </div>
            <p>To get started, just add a couple of necessary script tags:</p>
            <pre class="glass-bg code px-3 rounded">
              <code data-lang="html">
&lt;script src="https://cdn.jsdelivr.net/gh/alexseyka1/hier@master/src/hier-parser.js"&gt;&lt;/script&gt; 
&lt;script src="https://cdn.jsdelivr.net/gh/alexseyka1/hier@master/src/hier.js"&gt;&lt;/script&gt;</code>
            </pre>
            <p class="mt-4">
              The first script parses the string passed as a template literal and returns an AST tree, while the second
              script
              <ol>
                <li>Parses AST tree and creates components</li>
                <li>Renders them</li>
                <li>Mounts elements into a document</li>
                <li>And watches for changes</li>
              </ol>
            </p>
            <p>
              <a href="https://github.com/alexseyka1/hier" class="btn btn-outline-primary">
                <span class="fa-brands fa-github"></span>
                Download source from github
              </a> or use scripts directly from cdn described above.
            </p>
          </section>

          <section>
            <h2 id="starter-template" class="pt-3">Starter Template</h2>
            <p>
              If you are looking for an application template that you can simply paste on your site and have everything working right away, then just copy the code below:
            </p>

            <pre class="glass-bg code px-3 rounded">
              <code data-lang="html">
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hier starter template&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;

    &lt;!-- Core libraries --&gt;
    &lt;script src="https://cdn.jsdelivr.net/gh/alexseyka1/hier@master/src/hier-parser.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdn.jsdelivr.net/gh/alexseyka1/hier@master/src/hier.js"&gt;&lt;/script&gt;

    &lt;!-- Main script --&gt;
    &lt;script&gt;
    const { ast: html } = HierParser
    class App extends Hier.Component {
      _state = { liked: false }
      render() {
        const { liked } = this.state
        if (liked) return `You liked this!`
        
        return html`
          &lt;div&gt; Lets try to like this: &lt;/div&gt;
          &lt;button onClick=${() =&gt; this.setState({ liked: true })}&gt; ❤️Like &lt;/button&gt;
        `
      }
    }
    
    document.addEventListener("DOMContentLoaded", () =&gt; {
      Hier.render(App, document.getElementById("app"))
    })
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
            </pre>
          </section>

          <section>
            <h2 id="components" class="pt-3">Components</h2>

            <p>
              The library assumes that you break down all the functionality into separate components. Each component can have its own properties, state, and child elements.
            </p>

            <p>
              The component <strong>must</strong> be a javascript class and inherit from one of the two base classes provided by Hier:
              <ul>
                <li>
                  If the component is simple and relies only on the properties passed to it, then you should inherit the class from <code>Hier.BaseComponent</code>.
                  
                  <pre class="glass-bg code px-3 mt-2 rounded">
                    <code data-lang="javascript">
class Greeting extends Hier.BaseComponent {
  render() {
    const { name } = this.props
    
    return html`Hello, ${name}!`
  }
}</code>
                  </pre>

                  And then, to render this component, pass the parameter as an attribute:
                  <code>&lt;${Greeting} name="John" /&gt;</code>
                </li>

                <li class="mt-3">
                  And if the component also needs a state, then it should be inherited from <code>Hier.Component</code>.

                  <pre class="glass-bg code px-3 mt-2 rounded">
                    <code data-lang="html">
class LikeButton extends Hier.Component {
  _state = { liked: false }
  render() {
    const { name } = this.props
    const { liked } = this.state
    if (liked) return `${name} likes this!`
    
    return html`
      &lt;button onClick=${() =&gt; this.setState({ liked: true })}&gt; ❤️Like &lt;/button&gt;
    `
  }
}</code>
                  </pre>
                </li>
              </ul>
            </p>

            <p>
              You should understand that a component can display some information or not display anything, 
              while having some kind of logic inside itself.
            </p>
          </section>

          <section>
            <h3 id="components-constructor" class="pt-3">Component Constructor</h3>
            <p>
              When we talk about declaring a component class, it's important to clarify about its constructor. 
              If you need to subscribe to component life cycle events, bind some methods to an object, or do something else, 
              it is important to pass properties to the parent class at the very beginning of the constructor. 
              If this is not done, then the component properties will be unavailable.
            </p>
            <p>
              Just refer to the super class and pass properties to it:
            </p>
            <pre class="glass-bg code px-3 mt-2 rounded">
              <code data-lang="html">
constructor(props) {
  super(props)
  ... Here add the logic you need
}</code>
      </pre>
          </section>

          <section>
            <h3 id="components-lifecycle" class="pt-3">Component Lifecycle</h3>

            <p>
              A component has events that occur throughout its lifetime. You may need to take some action when certain events occur. In order to do this, you can subscribe to the event in the constructor and use as many callbacks as you like.
            </p>
            <pre class="glass-bg code px-3 mt-2 rounded">
                    <code data-lang="html">
constructor(props) {
  super(props)
  this.addEventListener("afterCreate", () => { ... })
}</code>
            </pre>

            <p>Or just add a method to the component with the name of the event you need.</p>
            <pre class="glass-bg code px-3 mt-2 rounded">
              <code data-lang="html">
class SuperComponent extends Hier.BaseComponent {
  afterCreate() {
  }

  afterMount() {
  }

  afterUpdate(props, prevProps, state, prevState) {
  }
  
  beforeUnmount() {
  }
}</code>
      </pre>

            <h4 class="my-4">More about each event</h4>

            <ol>
              <li>
                <strong>afterCreate</strong>
                <p>
                  Once created, the component object accesses the properties passed to it and fixes its initial state. The object then receives the <code>afterCreate</code> event.
                </p>
                <p class="alert alert-warning m-0">
                  This event fires every time the component is created. Not only during the rendering of the component to the page, but also during the <a href="#reconcillation">reconciliation process</a>.
                </p>
              </li>

              <li class="mt-3">
                <strong>afterMount</strong>
                <p>
                  When a component is embedded in a page, it and all of its child components receive the <code>afterMount</code> event. Here we recommend pulling data from the API or from any other storage, if necessary, of course. This event occurs once.
                </p>
              </li>

              <li class="mt-3">
                <strong id="components-lifecycle-after-update">afterUpdate</strong>
                <p>
                  Every time a component's properties have been changed, or the component has changed its internal state, it receives an <code>afterUpdate</code> event.
                </p>

                <p class="mb-1">
                  This is the only event that takes 4 arguments:
                </p>
                <ol class="mb-3">
                  <li>Current properties</li>
                  <li>Previous properties</li>
                  <li>Current state</li>
                  <li>Previous state</li>
                </ol>

                <p class="alert alert-warning">
                  The last two arguments will always be <strong>undefined</strong> if the component inherits from Hier.BaseComponent and does not have its own state.
                </p>
              </li>

              <li class="mt-3">
                <strong>beforeUnmount</strong>
                <p>
                  When a component is no longer needed and needs to be unmounted from the document, it receives the <code>beforeUnmount</code> event and is removed from the DOM tree. This event also fires only once.
                </p>
                <p>
                  Here we recommend unsubscribing from all events if you have previously subscribed and deleting interval actions and timers.
                </p>
              </li>
            </ol>
          </section>

          <section>
            <h3 id="components-props" class="pt-3">Component Properties</h3>
            <p>
              Since we describe all the markup inside template literals, to insert an existing component, 
              you need to add a tag and write the component name instead of the tag name.
              For a component with no children, write a self-closing tag:
            </p>
            <p><code>&lt;${MySuperComponentName} /&gt;</code></p>

            <p>
              To pass the properties we need to the component, pass them as attributes of this tag. 
              You can wrap attribute values in quotes, or you can not wrap them, as you like.
              Such a property can be passed as a string, array, or object:
            </p>
            <pre class="glass-bg code px-3 mt-2 rounded">
                <code data-lang="javascript">
const className = "container"
const numbers = [ 1, 2, 3, 4, 5 ]
const user = {
  id: 1,
  firstName: "John",
  lastName: "Doe"
}

return html`&lt;${MySuperComponentName} className=${className}
  orderIds=${numbers}
  installerUser=${user}
/&gt;</code>
            </pre>

            <p>
              Of course, you can substitute values within a string. To do this, wrap the attribute value in quotes:
            </p>
            <pre class="glass-bg code px-3 mt-2 rounded">
                <code data-lang="javascript">
const className = "container"

return html`&lt;${MySuperComponentName} className="${className} some-other-class" /&gt;`</code>
            </pre>

            <p>
              Or you can pass all attributes as a single object:
            </p>
            <pre class="glass-bg code px-3 mt-2 rounded">
                <code data-lang="javascript">
const attrs = {
  className: "container",
  numbers: [ 1, 2, 3, 4, 5 ],
  user: {
    id: 1,
    firstName: "John",
    lastName: "Doe"
  }
}

return html`&lt;${MySuperComponentName} ${attrs} /&gt;`</code>
            </pre>

            <p>
              Inside the component, you will get properties by the name of the specified attributes:
            </p>
            <pre class="glass-bg code px-3 mt-2 rounded">
              <code data-lang="javascript">
class MySuperComponentName extends Hier.BaseComponent {
  render() {
    const { className, orderId, installerUser } = this.props
    ...
  }
}</code>
            </pre>

            <h4 class="pt-3">Component's Children</h4>
            <p>
              To define child elements, simply write them inside the component tag. 
              The component will access them via this.props.children. 
              They won't be rendered unless specified by the component itself. 
              In this way, you can make wrapper components.
            </p>
            <p>
              To close a component tag you can use the component name again, but it can actually be anything:
            </p>
            <p>
              <code>&lt;${MyComponent}&gt; ...children... &lt;/MyComponent&gt;</code>
            </p>

            An example of a wrapper component:
            <pre class="glass-bg code px-3 mt-2 rounded">
              <code data-lang="javascript">
class Card extends Hier.BaseComponent {
  render() {
    const { children, header, footer } = this.props

    return html`&lt;div class="card"&gt;
      ${header && html`&lt;div class="card-header"&gt; ${header} &lt;/div&gt;`}
      &lt;!-- let's show child elements --&gt;
      &lt;div class="card-body"&gt; ${children} &lt;/div&gt;
      ${footer && html`&lt;div class="card-footer"&gt; ${footer} &lt;/div&gt;`}
    `
  }
}</code>
            </pre>

            An example of using this wrapper component:
            <pre class="glass-bg code px-3 mt-2 rounded">
              <code data-lang="javascript">
class App extends Hier.Component {
  render() {
    const header = html`&lt;div&gt; Some cool &lt;strong&gt;header&lt;/strong&gt; &lt;/div&gt;`
    const footer = html`&lt;a href="#" class="btn btn-primary"&gt; Go somewhere &lt;/a&gt;`

    return html`
      &lt;${Card} header=${header} footer=${footer}&gt;
        &lt;!-- children start here --&gt;
        &lt;h5 class="card-title"&gt; Card title here &lt;/h5&gt;
        &lt;p class="card-text"&gt; And some awesome text here. &lt;/p&gt;
        &lt;!-- and end here --&gt;
      &lt;/Card&gt;
    `
  }
}</code>
            </pre>
          </section>

          <section>
            <h3 id="components-state" class="pt-3">Component State</h3>
            <p>
              A regular component inherited from <code>Hier.BaseComponent</code> does not have its own state 
              and is updated only if updated properties were passed to it. 
              But sometimes you need to keep some data that is only needed inside the component, 
              and this data can be updated from time to time. 
              For such cases, you need to inherit your component from <code>Hier.Component</code>.
            </p>
            <p>
              If you need some data already at the time of creating the component, 
              you need to define the initialization state. 
              This can be done through the component's <code>_state</code> property or inside the constructor.
            </p>
            <pre class="glass-bg code px-3 mt-2 rounded">
              <code data-lang="javascript">
class App extends Hier.Component {
  _state = { time: null }

  constructor(props) {
    super(props)
    // this._state = { time: null }
  }
}</code>
            </pre>

            <div class="alert alert-warning">
              You can assign a value to the _state field only at the moment the component object is initialized. 
            </div>
            <p>
              In all other cases, to change the state, you need to call the <code>setState(partialState: object)</code> method 
              and pass it the object of the part of the state that you want to change. 
              The component will update its state with whatever you passed to it and fire the <a href="#components-lifecycle-after-update">afterUpdate</a> event.
            </p>

            <p>
              Below is an example of a simple component that shows the current time:
            </p>
            <pre class="glass-bg code px-3 mt-2 rounded">
              <code data-lang="javascript">
class CurrentTime extends Hier.Component {
  _state = { time: null }
  constructor(props) {
    super(props)
    this.interval = setInterval(() => this.setCurrentTime(), 1000)
  }

  afterMount() {
    this.setCurrentTime()
  }

  beforeUnmount() {
    clearInterval(this.interval)
  }

  setCurrentTime() {
    this.setState({
      time: new Date().toLocaleTimeString(),
    })
  }

  render() {
    return html`&lt;time&gt;${this.state.time}&lt;/time&gt;`
  }
}</code>
            </pre>
          </section>

          <section>
            <h2 id="reconcillation" class="pt-3">Reconciliation</h2>
            <p>
              The Hier library is very clever at rendering content to the page. 
              All components are fully rendered in html only once when the application is first launched. 
              In all other cases, Hier determines what exactly has changed and adjusts the DOM tree to match. 
              This process is called reconciliation.
            </p>
            <p>
              In order to do this, the library, after rendering the component, saves the parsed result 
              as a virtual tree for further comparison. 
              And if the virtual tree of the component has not changed, then no expensive operations 
              with the DOM will be performed, so redrawing will be fast.
            </p>
            <p>
              Let's say that the component draws some part of itself under a certain condition, 
              and if a new tag was added, Hier will create the missing DOM element and mount it in the document. 
              The rest of the component's content that is already rendered on the page will not be touched.

              <pre class="glass-bg code px-3 rounded">
                <code data-lang="html">
render() {
  const { liked } = this.state
  return html`
    &lt;p&gt;Some content&lt;/p&gt; &lt;!-- Already in document --&gt;
    ${liked && html`&lt;div&gt;New element&lt;/div&gt;`}
    &lt;p&gt;Some another content&lt;/p&gt; &lt;!-- Already in document --&gt;
  `
}</code>
              </pre>
            </p>
            <p>
              Also, if under a certain condition it is necessary to draw a component that did not exist before, 
              an instance of the component will be created, mounted in the document, and life cycle events will be called. 
              The rest of the DOM document will remain unchanged.

              <pre class="glass-bg code px-3 rounded">
                <code data-lang="html">
class NewComponent extends Hier.BaseComponent { ... }
...
class App extends Hier.Component {
  render() {
    const { liked } = this.state
    return html`
      &lt;p&gt;Some content&lt;/p&gt; &lt;!-- Already in document --&gt;
      ${liked && html`&lt;${NewComponent} /&gt;`}
      &lt;p&gt;Some another content&lt;/p&gt; &lt;!-- Already in document --&gt;
    `
  }
}</code>
              </pre>
            </p>
          </section>

          <section>
            <h2 id="parser" class="pt-3">Parser</h2>
            <p>
              The parser, which is presented in the file hier-parser.js, is responsible for parsing the template string, defining html elements, their tags, and components. It handles attribute values well, both quoted and unquoted. Values without quotes are conveniently passed as properties of components, they can be variables or inline values.
            </p>

            <strong>Input example:</strong>
            <pre class="glass-bg code px-3 rounded">
              <code data-lang="js">
html`
  &lt;h1&gt; First header &lt;/h1&gt;
  &lt;h2&gt;
    Second header
    &lt;a href="#"&gt; With link inside &lt;/a&gt;
  &lt;/h2&gt;
`</code>
            </pre>

            <strong>Output</strong>
            <pre class="glass-bg code px-3 rounded">
              <code data-lang="json">
[
  {
    "tagName": "h1",
    "props": {},
    "children": [
      {
        "tagName": "textString",
        "props": {
          "value": "First header"
        }
      }
    ]
  },
  {
    "tagName": "h2",
    "props": {},
    "children": [
      {
        "tagName": "textString",
        "props": {
          "value": "Second header"
        }
      },
      {
        "tagName": "a",
        "props": {
          "href": "#"
        },
        "children": [
          {
            "tagName": "textString",
            "props": {
              "value": "with link inside"
            }
          }
        ]
      }
    ]
  }
]</code>
            </pre>
            <p>
              You can just use this parser for your own purposes, but it works best in conjunction with the Hier renderer.
            </p>
          </section>
        </main>
      </div>
    </div>

    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js"
      integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"
      integrity="sha512-yUUc0qWm2rhM7X0EFe82LNnv2moqArj5nro/w1bi05A09hRVeIZbN6jlMoyu0+4I/Bu4Ck/85JQIU82T82M28w=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <!-- Core libraries -->
    <script src="https://cdn.jsdelivr.net/gh/alexseyka1/hier@master/src/hier-parser.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/alexseyka1/hier@master/src/hier.js"></script>

    <!-- Index script -->
    <script src="./index.js"></script>
  </body>
</html>
